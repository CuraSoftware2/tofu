<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>internal/bimonad · Tofu</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# Bimonad tutorial"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="internal/bimonad · Tofu"/><meta property="og:type" content="website"/><meta property="og:url" content="https://docs.tofu.tf/"/><meta property="og:description" content="# Bimonad tutorial"/><meta property="og:image" content="https://docs.tofu.tf/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://docs.tofu.tf/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="Tofu"/><h2 class="headerTitleWithLogo">Tofu</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/start" target="_self">Docs</a></li><li class=""><a href="/api/index.html" target="_self">API</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">internal/bimonad</h1></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="bimonad-tutorial"></a><a href="#bimonad-tutorial" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bimonad tutorial</h1>
<p>Bifunctors have become a hot topic in the Scala community since ZIO introduced the second type parameter.
It's a great way to manage business errors in your code, but it lacks suitable abstractions.
The most comprehensive set I've seen lies <a href="https://github.com/7mind/izumi/tree/develop/fundamentals/fundamentals-bio/src/main/scala/izumi/functional/bio">here</a>.
But it's built upon practical usage.
So let's start building a more principled approach.</p>
<h2><a class="anchor" aria-hidden="true" id="monads"></a><a href="#monads" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Monads</h2>
<p>Let's talk about the basic definitions. We will use the basic category theory terminology, most of which can be found on <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">Wikipedia</a> and <a href="https://ncatlab.org/nlab/show/monad">nLab</a>.
We will use the following definitions.</p>
<h3><a class="anchor" aria-hidden="true" id="category"></a><a href="#category" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Category</h3>
<p>Starting from this section, we will think of a Category as some entity with some additional structure.
The class mentioned below is something like a Set or a Type. Its elements are objects of the category. Since we want the object class to be arbitrary big (bigger than the classic Set could be) and we do not need equality/identity relation on it, we will denote it <em>Class</em>.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Category_(mathematics)">category</a> <code>C</code> is a Class called <em>objects</em> together with an indexed set family <code>Hom: (C, C) -&gt; Set</code> and functions</p>
<pre><code class="hljs">id : ∀(<span class="hljs-selector-tag">a</span>: C), Hom(<span class="hljs-selector-tag">a</span>, a)

∘ : ∀{<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c : C}, (Hom(<span class="hljs-selector-tag">b</span>, c), Hom(<span class="hljs-selector-tag">a</span>, b)) -&gt; Hom(<span class="hljs-selector-tag">a</span>, c) 
</code></pre>
<p>and the following properties</p>
<pre><code class="hljs">left-id : ∀{a, b: C}, ∀(f: <span class="hljs-constructor">Hom(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>), id b ∘ f = f

right-id : ∀{a, b: C}, ∀(f: <span class="hljs-constructor">Hom(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>), f ∘ id a = f

associativity : ∀{a, b, c, d: C}, ∀(f: <span class="hljs-constructor">Hom(<span class="hljs-params">c</span>, <span class="hljs-params">d</span>)</span>), ∀(g: <span class="hljs-constructor">Hom(<span class="hljs-params">b</span>, <span class="hljs-params">c</span>)</span>), ∀(h: <span class="hljs-constructor">Hom(<span class="hljs-params">c</span>, <span class="hljs-params">d</span>)</span>), ∀(h: <span class="hljs-constructor">Hom(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>), f ∘ (g ∘ h) = (f ∘ g) ∘ h
</code></pre>
<p>The most acknowledged category in a functional programming language is a <code>Set</code>-like category of inhabitable types and pure total functions between them, so the objects are types, and for types <code>A</code> and <code>B</code> <code>Hom(A, B)</code> is a set of pure functions <code>A =&gt; B</code>. For Scala, we will call it <code>Scala</code>.</p>
<p>Another sort of category that Scala types form is subtyping relations, i.e. we have a single element <code>Hom(A, B)</code> when <code>A &lt;: B</code> and an empty Hom otherwise.</p>
<h3><a class="anchor" aria-hidden="true" id="functor"></a><a href="#functor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functor</h3>
<p>A functor <code>F</code> between categories <code>C</code> and <code>D</code> is a function <code>C -&gt; D</code> together with a family of functions</p>
<pre><code class="hljs">map: ∀<span class="hljs-comment">(a, b: C)</span>, Hom<span class="hljs-comment">(a, b)</span> -&gt; Hom<span class="hljs-comment">(F(a)</span>, F<span class="hljs-comment">(b)</span>)
</code></pre>
<p>and the following properties</p>
<pre><code class="hljs">functor-id: ∀(<span class="hljs-selector-tag">a</span>: C), map(F)(id a) = id <span class="hljs-selector-tag">b</span>
functor-compose: ∀(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>, c: C), ∀(f: Hom(<span class="hljs-selector-tag">b</span>, c), g: Hom(<span class="hljs-selector-tag">a</span>, b)),  map{F}(f ∘ g) = map{F}(f) ∘ map{F}(g)
</code></pre>
<p>The most beloved form of functors are endo-functors <code>Scala</code> -&gt; <code>Scala</code>, whose interface looks like</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Functor</span>[<span class="hljs-type">F</span>[_]]</span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
}
</code></pre>
<p>or more commonly in the uncurried form</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Functor</span>[<span class="hljs-type">F</span>[_]]</span>{
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
}
</code></pre>
<p>properties are assumed for implementations</p>
<p>there are some other interesting functors, for example</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Invariant</span>[<span class="hljs-type">F</span>[_]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>)(g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
}
</code></pre>
<p>is an interface for functors from a Scala-<a href="https://ncatlab.org/nlab/show/core">core</a>, i.e. category of all Scala isomorphisms to Scala</p>
<p>Notable endofunctor for any category is identity functor <code>Id</code> such that</p>
<pre><code class="hljs"><span class="hljs-function"><span class="hljs-title">Id</span><span class="hljs-params">(a)</span></span> = <span class="hljs-selector-tag">a</span>
map{Id}(f) = f
</code></pre>
<p>Also for any triple of categories C, D, E, having functors <code>F: D -&gt; E</code>  and <code>G: C -&gt; D</code> we can define composition of functors</p>
<pre><code class="hljs css language-text">(F ∘ G)(a) = F(G(a))
map{F ∘ G}(f) = map{F}(map{G}(f))
</code></pre>
<p><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<h3><a class="anchor" aria-hidden="true" id="transformations"></a><a href="#transformations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Transformations</h3>
<p>This section has a lot of unnecessary info, so you can skip it</p>
<p>Having categories <code>C</code> and <code>D</code>,  functors <code>F, G : C -&gt; D</code>,  natural transformation <code>ф : F -&gt; G</code></p>
<pre><code class="hljs">∀<span class="hljs-comment">(a: C)</span>, F<span class="hljs-comment">(a)</span> -&gt; G<span class="hljs-comment">(a)</span>
</code></pre>
<p>together with property</p>
<pre><code class="hljs">naturality: ∀(<span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span>: C), f: Hom(<span class="hljs-selector-tag">a</span>, b), ф{b} ∘ map{F}(f) = map{G}(f) ∘ ф{a}
</code></pre>
<p>in scala, if we are talking about endofunctors <code>Scala -&gt; Scala</code> we consider it having the following interface</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">FunctionK</span>[<span class="hljs-type">F</span>[_], <span class="hljs-title">G</span>[_]]</span>{ 
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">A</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]): <span class="hljs-type">G</span>[<span class="hljs-type">A</span>]
}
</code></pre>
<p>Still <code>F</code> and <code>G</code> don't have to be Functors at all, so we can talk about just transformation (not natural) between type-constructors.<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>For natural transformations, we can talk about identity and composition as well.
For any functor F, identity transformation is defined by</p>
<pre><code class="hljs"><span class="xml">tid</span><span class="hljs-template-variable">{F}</span><span class="xml"></span><span class="hljs-template-variable">{a}</span><span class="xml"> = id</span><span class="hljs-template-variable">{F(a)}</span><span class="xml">
</span></code></pre>
<p>Moreover for categories <code>C</code>, <code>D</code> and functors <code>F</code>, <code>G</code>, <code>H</code> from C to D,  (vertical) composition of transformations <code>ф : G -&gt; H</code> and <code>ц : F -&gt; G</code> is defined as</p>
<pre><code class="hljs css language-text">(ф ∘ ц){a} = ф{a} ∘ ц{a}
</code></pre>
<p>We can apply functor to the transformation at whole, supposing element-wise application, i.e. having categories
<code>C</code> ,<code>D</code>, <code>E</code> and functors <code>F: C -&gt; D</code>, <code>G: C -&gt; D</code> and <code>H : D -&gt; E</code>, transformation <code>ф : F -&gt; G</code>, we define new transformation from <code>H ∘ F</code> to <code>H ∘ G</code> as application <code>H</code> to <code>ф</code> :</p>
<pre><code class="hljs css language-text">H(ф){a} = map{H}(ф{a})
</code></pre>
<p>Also we can apply transformation to a functor, i.e. having categories
<code>C</code> ,<code>D</code>, <code>E</code> and functors <code>F: D -&gt; E</code>, <code>G: D -&gt; E</code> and <code>H : C -&gt; D</code>, transformation <code>ф : F -&gt; G</code>, we define new transformation from <code>F ∘ H</code> to <code>G ∘ H</code> as an application of <code>ф</code> to <code>H</code> :</p>
<pre><code class="hljs css language-text">ф(H){a} = ф{H(a)}
</code></pre>
<p>Generalizing that we can define the horizontal composition of transformations.
For any categories<code>C, D, E</code> , functors <code>F, G: D -&gt; E</code> and <code>H, I : C -&gt; D</code> and transformations <code>ф: F -&gt; G</code> <code>ц: H -&gt; I</code> , horizontal composition
<code>ф ● ц : F ∘ H -&gt; G ∘ I</code> is defined as</p>
<pre><code class="hljs css language-text">ф ● ц {a} = ф{G(a)} ∘ map{H}(ц{a})
</code></pre>
<p>We can say that <code>ф ● ц = ф(G) ∘ H(ц)</code>, or <code>ф(F) = ф ● tid{F}</code> and <code>F(ф) = tid{F} ● ф</code></p>
<h3><a class="anchor" aria-hidden="true" id="monad"></a><a href="#monad" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Monad</h3>
<p>The traditional definition of a monad is the following: Monad <code>F</code> in category <code>C</code> is an endofunctor together with following natural transformations:</p>
<pre><code class="hljs css language-text">ν : Id -> F
μ : F ∘ F -> F
</code></pre>
<p>and properties</p>
<pre><code class="hljs css language-text">left-identity:  μ ∘ ν(F) = tid{F}
right-identity: μ ∘ F(ν) = tid{F}
associativity:  μ ∘ μ(F) = μ ∘ F(μ)
</code></pre>
<p>These definitions should lead us to the definition of Monad in <code>Scala</code> like that</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Monad</span>[<span class="hljs-type">F</span>[_]] <span class="hljs-keyword">extends</span> <span class="hljs-title">Functor</span>[<span class="hljs-type">F</span>]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">map</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatten</span></span>[<span class="hljs-type">A</span>](ffa: <span class="hljs-type">F</span>[<span class="hljs-type">F</span>[<span class="hljs-type">A</span>]]): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]
}
</code></pre>
<p>It has three methods to define and seven properties to prove (functor-id, functor-compose, naturality of pure, naturality of <code>flatten</code>, <code>left-identity</code>, <code>right-identity</code> and <code>associativity</code>)</p>
<p>Meanwhile, even in general form in category theory, we can merge all the definitions into one and get a Hom-form of Monad definition</p>
<p>So, monad <code>F</code> in a category C is a function <code>C -&gt; C</code> (e.g. unary type-constructor in Scala), together with the following function families</p>
<pre><code class="hljs">pure: ∀a: C, Hom<span class="hljs-comment">(a, F(a)</span>)
flatMap: ∀<span class="hljs-comment">(a, b: C)</span>, Hom<span class="hljs-comment">(a, F(b)</span>) -&gt; Hom<span class="hljs-comment">(F(a)</span>, F<span class="hljs-comment">(b)</span>)
</code></pre>
<p>together with the following laws</p>
<pre><code class="hljs">left-identity: ∀(a, b: C), f: <span class="hljs-constructor">Hom(<span class="hljs-params">a</span>, <span class="hljs-params">b</span>)</span>, flat<span class="hljs-constructor">Map(<span class="hljs-params">f</span>)</span> ∘ pure{b} = f
right-identity: ∀a: C, flat<span class="hljs-constructor">Map(<span class="hljs-params">pure</span>{<span class="hljs-params">a</span>})</span> = id{<span class="hljs-constructor">F(<span class="hljs-params">a</span>)</span>}
associativity: ∀(a, b, c: C),f: <span class="hljs-constructor">Hom(<span class="hljs-params">b</span>, F(<span class="hljs-params">c</span>)</span>), g: <span class="hljs-constructor">Hom(<span class="hljs-params">a</span>, F(<span class="hljs-params">b</span>)</span>), flat<span class="hljs-constructor">Map(<span class="hljs-params">f</span>)</span> ∘ flat<span class="hljs-constructor">Map(<span class="hljs-params">g</span>)</span> = flat<span class="hljs-constructor">Map(<span class="hljs-params">flatMap</span>(<span class="hljs-params">f</span>)</span> ∘ g)
</code></pre>
<p>using these properties we can prove all seven properties for the original monad and vice versa. So it's just another definition for the same abstraction</p>
<p>that immediately gives us another form for monad interface</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Monad</span>[<span class="hljs-type">F</span>[_]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
}
</code></pre>
<p>or in the uncurried version</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Monad</span>[<span class="hljs-type">F</span>[_]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pure</span></span>[<span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](fa: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">B</span>]
}
</code></pre>
<p>Here we need to prove three well-known monad laws. Then functor laws, naturality restrictions, and original monad laws arise immediately.</p>
<h2><a class="anchor" aria-hidden="true" id="bifunctors"></a><a href="#bifunctors" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bifunctors</h2>
<h3><a class="anchor" aria-hidden="true" id="product-of-categories"></a><a href="#product-of-categories" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Product of categories</h3>
<p>For any categories <code>C</code> and <code>D</code> we can define their product <code>C × D</code> as a category, which objects are pairs <code>(a, x)</code> where <code>a</code> is an object of <code>C</code> and <code>x</code> is an object of <code>D</code>
Then <code>Hom((a, x), (b, y))</code> is a <code>Hom(a, b) × Hom(x, y)</code>, i.e. set of pairs <code>(f, u)</code> where <code>f</code> is an element of <code>Hom(a, b)</code> and <code>u</code> is an element of <code>Hom(x, y)</code></p>
<p>Rest of the structure defined as follows</p>
<pre><code class="hljs css language-text">id{(a, x)} = (id{a}, id{x})
(f, u) ∘ (g, v) = (f ∘ g, u ∘ v)
</code></pre>
<p>And properties are easy to prove.</p>
<h3><a class="anchor" aria-hidden="true" id="bifunctor"></a><a href="#bifunctor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bifunctor</h3>
<p>Bifunctor is just a word meaning &quot;functor from the product of categories&quot;, so bifunctor <code>C × D -&gt; E</code> is just a functor <code>C × D -&gt; E</code></p>
<p>Technically that means that we have a binary function on objects and
mapping function, that mapping couple of functions into a single one.</p>
<p>So bifunctor <code>Scala × Scala -&gt; Scala</code> would have following interface</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Bifunctor</span>[<span class="hljs-type">F</span>[_, _]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bimap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>, g: <span class="hljs-type">C</span> =&gt; <span class="hljs-type">D</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]
}
</code></pre>
<p>One notable property of bifunctors is orthogonality of mappings, meaning</p>
<pre><code class="hljs">(f, <span class="hljs-built_in">id</span>) ∘ (<span class="hljs-built_in">id</span>, g) = (f ∘ <span class="hljs-built_in">id</span>, <span class="hljs-built_in">id</span> ∘ g) = (f, g) = (<span class="hljs-built_in">id</span> ∘ f, g ∘ <span class="hljs-built_in">id</span>) = 
    (<span class="hljs-built_in">id</span>, g) ∘ (f, <span class="hljs-built_in">id</span>)
</code></pre>
<p>and for bifunctor <code>F</code> it would mean that</p>
<pre><code class="hljs css language-text">map{F}(f, id) ∘ map{F}(id, g) = map{F}(id, g) ∘ map{F}(f, id)
</code></pre>
<p>Which looks like some form of commutativity, but is not since <code>id</code>s have different implicit indices</p>
<p>But it allows to define bifunctor in the following form</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Bifunctor</span>[<span class="hljs-type">F</span>[_, _]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">C</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">B</span>, <span class="hljs-type">C</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rmap</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>](f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">A</span>] =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">A</span>]
}
</code></pre>
<p>So we definitely may split any mappings to left and right components</p>
<h3><a class="anchor" aria-hidden="true" id="bifunctor-monad"></a><a href="#bifunctor-monad" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Bifunctor monad</h3>
<p>So what is a monad which is also bifunctor? It should be an endofunctor from a product of some categories, implying that it's a functor which results also in a product of these categories,</p>
<pre><code class="hljs">pure: ∀a: C, x: D, <span class="hljs-constructor">Hom((<span class="hljs-params">a</span>, <span class="hljs-params">x</span>)</span>, <span class="hljs-constructor">F(<span class="hljs-params">a</span>, <span class="hljs-params">x</span>)</span>)
flatMap: ∀(a, b: C), (x, y: D), <span class="hljs-constructor">Hom((<span class="hljs-params">a</span>, <span class="hljs-params">x</span>)</span>, <span class="hljs-constructor">F(<span class="hljs-params">b</span>, <span class="hljs-params">y</span>)</span>) -&gt; <span class="hljs-constructor">Hom(F(<span class="hljs-params">a</span>, <span class="hljs-params">x</span>)</span>, <span class="hljs-constructor">F(<span class="hljs-params">b</span>, <span class="hljs-params">y</span>)</span>)
</code></pre>
<p>But here we must remember that F is a function to a pair of objects.<br>
How can we represent such thing on scala types?<br>
We can immediately think of any function resulting in a pair as a pair of functions, producing corresponding elements of pair.
Meaning that <code>F: A -&gt; B × C</code> can be represented <code>F_1: A -&gt; B</code> and <code>F_2: A -&gt; C</code> and <code>F(a) = (F_1(a), F_2(a))</code>.<br>
So a binary function from types to a pair of types we can represent as a pair of type constructors.
Same trick will work for components of <code>pure</code> and <code>flatMap</code> : instead of tuple of functions as a result we define two different methods for each component
There for a bifunctor monad
<code>Scala × Scala -&gt; Scala × Scala</code> would look as</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">BiMonad</span>[<span class="hljs-type">L</span>[_, _], <span class="hljs-title">R</span>[_, _]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pureLeft</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">L</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pureRight</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](b: <span class="hljs-type">B</span>): <span class="hljs-type">R</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMapLeft</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](fl: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">L</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>], fr: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">R</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]): <span class="hljs-type">L</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">L</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">flatMapRight</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](fl: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">L</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>], fr: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">R</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]): <span class="hljs-type">R</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>] =&gt; <span class="hljs-type">R</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]
}
</code></pre>
<p>We can easily uncurry that and define bifunctors for both <code>L</code> and <code>R</code> using such definitions.</p>
<h3><a class="anchor" aria-hidden="true" id="twin-monad"></a><a href="#twin-monad" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Twin monad</h3>
<p>Such definitions are still unsettling. It is hard to imagine how it could be useful having two different type-constructors. So the most obvious way of narrowing our definition is requiring that
<code>R = L</code>, then our definitions of <code>flatMapLeft</code> and <code>flatMapRight</code> become identical and can be further merged into one method.</p>
<p>So now we with just three methods for which we can imagine fancy names.</p>
<p><code>pureLeft</code> we will call <code>raise</code> as it was raising errors
<code>pureRight</code> we will call <code>pure</code> since right side we decide to be the <em>right side</em>
and merged <code>flatMap</code> we will call <code>foldWith</code> since it provides a way to continue from both success and error and has some resemblance with <code>fold</code> method on well-known bifunctors like <code>Either</code> now we get our glorious and uncurried</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">TwinMonad</span>[<span class="hljs-type">F</span>[_, _]]</span>{
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">raise</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](a: <span class="hljs-type">A</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">success</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>](b: <span class="hljs-type">B</span>): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>]
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldWith</span></span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>, <span class="hljs-type">C</span>, <span class="hljs-type">D</span>](fab: <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">B</span>])(f: <span class="hljs-type">A</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>], g: <span class="hljs-type">B</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">C</span>, <span class="hljs-type">D</span>]
}
</code></pre>
<p>Following the Monad laws, we derive 4 fundamental laws for the TwinMonad<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p>
<p>In the following code all the parameters (types and values) implied to be universally quantifined (<em>for all</em>) , and the resulting equality type <code>:=:</code> - is the required property</p>
<pre><code class="hljs css language-scala">    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">raiseFold</span></span>[<span class="hljs-type">E1</span>, <span class="hljs-type">A1</span>, <span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>](e: <span class="hljs-type">E1</span>)(f: <span class="hljs-type">E1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>])(g: <span class="hljs-type">A1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>]) : 
        foldWith(raise(e))(f, g) :=: f(e)
    
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">successFold</span></span>[<span class="hljs-type">E1</span>, <span class="hljs-type">A1</span>, <span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>](a: <span class="hljs-type">A1</span>)(f: <span class="hljs-type">E1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>])(g: <span class="hljs-type">A1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>]) : 
        foldWith(raise(e))(f, g) :=: g(a)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldPure</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](fea: <span class="hljs-type">F</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]) : foldWith(fea)(raise)(success) :=: fea

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foldAssoc</span></span>[<span class="hljs-type">E1</span>, <span class="hljs-type">A1</span>, <span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>, <span class="hljs-type">E3</span>, <span class="hljs-type">A3</span>](
        fea: <span class="hljs-type">F</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]
    )(
        f1: <span class="hljs-type">E1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>], g1: <span class="hljs-type">A1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>]
    )(
        f2: <span class="hljs-type">E2</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E3</span>, <span class="hljs-type">A3</span>], g2: <span class="hljs-type">A2</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E3</span>, <span class="hljs-type">A3</span>]
    ): foldWith(foldWith(fea)(f1, g1))(f1, g1) :=: foldWith(fea)(e =&gt; foldWith(f1(e))(f2, g2), a =&gt; foldWith(g1(a))(f2, g2qq)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="symmetry"></a><a href="#symmetry" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Symmetry</h3>
<p>so right from this, we may define the following method</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](fea: <span class="hljs-type">F</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]): <span class="hljs-type">F</span>[<span class="hljs-type">A</span>, <span class="hljs-type">E</span>] = foldWith(fea)(success, raise)
</code></pre>
<p>and directly from the laws we can prove following lemmas</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapInvolutive</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](fea: <span class="hljs-type">F</span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>]): swap(swap(fea)) :=: fea
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapRaise</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](e: <span class="hljs-type">E</span>): swap(raise(e)) :=: success(e)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapSuccess</span></span>[<span class="hljs-type">E</span>, <span class="hljs-type">A</span>](a: <span class="hljs-type">A</span>): swap(success(a)) :=: raise(e)
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swap-fold</span></span>[<span class="hljs-type">E1</span>, <span class="hljs-type">A1</span>, <span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>](fea: <span class="hljs-type">F</span>[<span class="hljs-type">E1</span>, <span class="hljs-type">A1</span>])(f: <span class="hljs-type">E1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>])(g: <span class="hljs-type">A1</span> =&gt; <span class="hljs-type">F</span>[<span class="hljs-type">E2</span>, <span class="hljs-type">A2</span>]) : 
    foldWith(swap(fea)(g, f) = foldWith(fea)(f, g)
</code></pre>
<p>So our monad has a powerful quality of symmetry. We require that monad treats errors and successes equally, so we can switch between them whenever we want.
All types that can't satisfy this property we reject.
Moreover, in all the abstractions on top of <code>TwinMonad</code>, we'll search for the same symmetry, trying not to think of one binding channel more than of another.
That will help us to find correct shapes in the binary monad universe.</p>
<h3><a class="anchor" aria-hidden="true" id="stack-safety"></a><a href="#stack-safety" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Stack safety</h3>
<p>To restore the same stack-safe qualities that are already in the <code>cats</code> we add another iterative form of <code>foldWith</code> called <code>foldRec</code>.
<code>def foldRec[E, A, X, B](init: Either[E, A])(step: Either[E, A] =&gt; F[Either[E, X], Either[A, B]]): F[X, B]</code> - here <code>E</code> and <code>A</code> are type parameters for the intermediate results, while we have <code>Left(e: E)</code> on the error channel or <code>Left(a: A)</code> on the right channel the iteration continues. As soon as we reached <code>Right(x :X)</code> on the left or <code>Right(b: B)</code> on the right, we must stop, finalizing the result.</p>
<p>Resulting bifunctor brother of <code>cats.Monad</code> we call <code>Bind</code> which I feel is nice for two reasons:</p>
<ol>
<li>It starts with <code>Bi</code> so it's easy to recall it when you are thinking about bifunctors</li>
<li>Its name resembles is a common alias for the <code>flatMap</code> method, so it's easy to recall it as a <code>Monad</code></li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1"  class="footnote-item"><p>We may consider a category of categories, where functors are morphisms. Such functors would play the role of an identity morphism and composition here <a href="#fnref1" class="footnote-backref">↩</a></p>
</li>
<li id="fn2"  class="footnote-item"><p>Note that if we consider the category of scala types, where all <code>Hom</code>s are empty, any type constructor there would be a functor, and any transformation would be natural. <a href="#fnref2" class="footnote-backref">↩</a></p>
</li>
<li id="fn3"  class="footnote-item"><p>These and others proofs can be found in <a href="https://github.com/Odomontois/Tincat/blob/master/src/Functor/Monad.ard">our Arend repository dedicated to Category Theory</a> <a href="#fnref3" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#monads">Monads</a><ul class="toc-headings"><li><a href="#category">Category</a></li><li><a href="#functor">Functor</a></li><li><a href="#transformations">Transformations</a></li><li><a href="#monad">Monad</a></li></ul></li><li><a href="#bifunctors">Bifunctors</a><ul class="toc-headings"><li><a href="#product-of-categories">Product of categories</a></li><li><a href="#bifunctor">Bifunctor</a></li><li><a href="#bifunctor-monad">Bifunctor monad</a></li><li><a href="#twin-monad">Twin monad</a></li><li><a href="#symmetry">Symmetry</a></li><li><a href="#stack-safety">Stack safety</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/" class="nav-home"><img src="/img/favicon.ico" alt="Tofu" width="66" height="58"/></a><div><h5>Docs</h5><a href="/docs/start.html">Getting Started</a></div><div><h5>Community</h5><a href="/en/users.html">User Showcase</a><a href="https://stackoverflow.com/questions/tagged/tofu" target="tofu" rel="noreferrer noopener">Stack Overflow</a><a href="https://t.me/tofu_scala">Telegram Group (EN|RU)</a><a href="https://gitter.im/tinkoff-tofu/community">Gitter Group (EN)</a></div><div><h5>More</h5><a href="/blog">Blog</a><a href="https://github.com/tofu-tf/tofu">GitHub</a><a class="github-button" href="https://github.com/tofu-tf/tofu" data-icon="octicon-star" data-count-href="/TinkoffCreditSystems/tofu/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2021 Tinkoff.ru</section></footer></div></body></html>