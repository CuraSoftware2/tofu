---
id: tofu.logging.recipes
title: Tofu Logging recipes
---


# Recipes

Here is the list of ways how one can use `tofu.logging`

For any of the recipes you going to need two things:
- Ensure all the data types you log have instance of Loggable (todo link to core concepts);
- import syntax: `import tofu.syntax.logging._`


## Simple logging
All you need to do to start using logging in its simplest form is the following:
- add Logging.Make as parameter to your service â€” that will describe the capability to create `Logging`s;
- create logging instance with method `Logging.make.plain[F]`

That's it!

```scala
class MyService[F[_]: Monad: Logging.Make](someDependency: DependencyService){

  private implicit val logging: Logging[F] = Logging.Make[F].forService[MyService[F]]
  
  def makeThis: F[Unit] = someDependency.foo(30) >> info"Something"

  def makeThat: F[Unit] = someDependency.foo(30).flatTap(result => warn"Some another thing $result")
}
```
At the app creation point you'll need to create the instance of Logging.Make by the method `Logging.Make.plain`:
```scala
def run: IO[ExitCode] = {
  implicit val makeLogging: Logging.Make[IO] = Logging.Make.plain[IO]
  
  val myService = new MyService[IO](???)
  
  ???//the rest of the app
}
```
And if you have context inside your `F` you can use method `Logging.Make.contextual[F, Ctx]`:
```scala
def run: IO[ExitCode] = {
  implicit val makeLogging: Logging.Make[ReaderT[IO, SomeContext, *]] = Logging.Make.contextual[ReaderT[IO, SomeContext, *], SomeContext]

  val myService = new MyService[ReaderT[IO, SomeContext, *]](???)

  ???//the rest of the app
}
```

## Tagged simple logging
You can also use tagged logging just for this service:

```scala
class MyService[F[_]: Monad: MyService.Log](someDependency: DependencyService){
  
  
  def makeThis: F[Unit] = someDependency.foo(30) >> info"Something"
  
  def makeThat: F[Unit] = someDependency.foo(30).flatTap(result => warn"Some another thing $result")
}

object MyService extends LoggingCompanion[MyService]
```

The line `object MyService extends LoggingCompanion[MyService]` mixes into the companion object type Log, which is just alias for `ServiceLogging[F, MyService]` (todo link to core concepts).

And in the wiring of the app:

```scala
import cats.effect.ExitCode
def run: IO[ExitCode] = {
  implicit val logs: Logging.Make[IO] = Logging.Make.plain[IO]
  
  val service = new MyService[IO](???)
}
```
The `MyService.Log` instance is created implicitly just for this service from implicit value of `Logging.Make`.

## Autogenerated logging
You can automatically generate log messages stating when the method of some service has been entered and left.
```scala
@derive(representableK, loggingMid)
trait MyService[F[_]]{
  def makeThis: F[Unit]
  def makeThat(arg1: Int, arg2: String): F[Long]
}

object MyService extends LoggingCompanion[MyService]{
  
  def make[F[_]: Logs.Make: Monad]: MyService[F] = {
    val core = new Impl[F]
    core.attachLogs
  }
  
  class Impl[F[_]: Monad] extends MyService[F]{
    //implementation
  }
}
```

## Your own specific logs

tofu.logging allows you to use your own backend for logs, e.g. to send them to Clickhouse.
To do this you'll need to implement `Logs` trait. The rest is still handled by tofu.

Let's say you have this clickhouse client:
```scala
trait ClickhouseClient[F[_]]{
  def send[A](data: A): F[Unit]
  def initTable(name: String): F[Unit]
}
```
You'll need to implement only one method to create Logs:
```scala
def clickhouseLogs[F[_]](client: ClickhouseClient[F])(logs: Logs[F, F]) = 
  new Logs[F, F] {
      def byName(name: String): F[Logging[F]] = 
        for {
        _ <- client.initTable("logs")
        logging = logs.byName(name)
      } yield logging //todo how tf to implement this nicely?
  }
```

